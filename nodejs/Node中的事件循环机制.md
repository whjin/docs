`Node.js`在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时（没有请求接入时），就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非`I/O`任务，就亲自处理，并通过回调函数返回到上层调用；如果是`I/O`任务，就从线程池中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。

当线程中的`I/O`任务完成后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。这个过程就叫事件循环（`Event Loop`）。

`Node.js`内部都是通过线程池来完成异步`I/O`操作的，而`LIBUV`针对不同平台的差异性实现了统一调用。因此，`Node.js`的单线程仅仅是指`JS`运行在单线程中，而非`Node.js`是单线程。

`Node.js`的事件循环分为`6`个阶段：

1. `timers`阶段：这个阶段执行`timer`（`setTimeout`、`setInterval`）的回调
2. `I/O callbacks`阶段：处理一些上一轮循环中的少数未执行的`I/O`回调
3. `idle`、`prepare`阶段：仅`Node.js`内部使用
4. `poll`阶段：获取新的`I/O`事件，适当的条件下`Node.js`将阻塞在这里
5. `check`阶段：执行`setImmediate`的回调
6. `close callbacks`阶段：执行`socket`的`close`事件回调

事件循环的执行顺序：外部输入数据-->轮询阶段`poll`-->检查阶段`check`-->关闭事件回调阶段`close callback`-->定时器检测阶段`timer`-->`I/O`事件回调阶段`I/O callbacks`-->闲置阶段`idle、prepare`-->轮询阶段（按照该顺序反复运行）

浏览器和`Node.js`环境下，微任务任务队列的执行时机不同：

- `Node.js`端，微任务在事件循环的各个阶段之间执行
- 浏览器端，微任务在事件循环的宏任务执行完之后执行