1、类的创建，`new`一个`function`，在这个`function`的原型对象`prototype`里添加属性方法。

`new`操作符新建一个空对象，这个对象原型（`__proto__`）指向构造函数的`prototype`，执行构造函数后返回这个对象。

2、类的继承

-  原型链继承，`new`一个空对象，这个空对象指向`Animal`并且`Cat.prototype`指向了这个空对象

    核心：将父类的实例作为子类的原型
	特点：
	基于原型链，既是父类的实例，又是子类的实例
	父类新增原型方法/原型属性，子类都能访问
	缺点：
	为子类新增属性和方法，不能放到构造器中
	无法实现多继承
	来自原型对象的所有属性被所有实例共享
	创建子类实例时，无法向父类构造函数传参

- 构造继承

    核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）
	特点：
	解决了子类实例共享父类引用属性的问题
	创建子类实例时，可以向父类传递参数
	可以实现多继承（`call`多个父类对象）
	缺点：
	实例并不是父类的实例，只是子类的实例
	只能继承父类实例的属性和方法，不能继承原型上的属性和方法
	无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

- 实例继承和拷贝继承

	实例继承：为父类实例添加新特性，作为子类实例返回
	拷贝继承：拷贝父类元素上的属性和方法

- 组合继承，相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。

	特点：
	可以继承实例属性和方法，也可以继承原型属性和方法
	既是子类的实例，又是父类的实例
	不存在引用属性共享问题
	可传参
	函数可复用
	缺点：调用了两次父类构造函数，生成了两份实例

- 寄生组合继承，通过寄生方式，去掉父类的实例属性，在调用两次父类的构造函数的时候，就不会初始化两次实例属性和方法。(推荐继承方法)


[类的创建与继承代码](https://github.com/whjin/docs/blob/main/javascript/src/%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF.js)

