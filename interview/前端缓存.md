缓存分为两种：强缓存和协商缓存，根据响应的`header`内容来决定。

|缓存类型|状态码|发送请求到服务器|
|-------|-----|--------------|
|强缓存|`200`（`From Cache`）|否，直接从缓存取|
|协商缓存|`304`（`Not Modified`）|是，通过服务器来告知缓存是否可用|

---------------

**强缓存**

强缓存字段：`expires`(已废弃)、`cache-control`。`cache-control`与`expires`同时存在，`cache-control`的优先级高于`expires`(已废弃)。

强缓存利用`http`头中的`Cache-Control`和`Expires`(已废弃)两个字段来控制，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除，需要强制刷新。浏览器强制刷新，请求会带上`Cache-Control:no-cache`和`Pragmatic:no-cache`。

`Cache-Control`主要利用`max-age`值进行判断，它是一个相对时间。

`Cache-Control`常见的值：`private`、`public`、`no-cache`、`no-store`、`max-age`、`s-maxage`、`must-revalidate`

- `max-age`：客户端资源被缓存多久。
- `s-maxage`：代理服务器缓存的时长。
- `no-cache`：强制进行协商缓存，不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在`Etag`，请求时先与服务端验证，如果资源未被更改，则可以避免重新下载。
- `no-store`：禁止任何缓存策略。直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
- `public`：资源既可以被浏览器缓存又可以被代理服务器缓存。
- `private`：资源只能被浏览器缓存。

---------------

**协商缓存**

协商缓存由服务器来确定缓存资源是否可用，客户端与服务器端通过某种标识进行通信。

普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存。

**基于`Last-Modified`的协商缓存**

- 首先需要在服务器端读出文件修改时间
- 将读出的修改时间赋给响应头的`Last-Modified`字段
- 最后设置`Cache-Control: no-cache`

当客户端读取到`Last-Modified`时，会在下次的请求标头中携带一个字段`If-Modified-Since`。

每次对该资源的请求，都会带上`If-Modified-Since`字段，服务端需要拿到这个时间并再次读取该资源的修改时间，两个时间进行比对决定是读取缓存环视返回新的资源。

**基于`Etag`的协商缓存**

`Etag`将原先协商缓存的比较时间戳的形式修改为比较文件指纹。

文件指纹：根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。

1. 第一次请求资源，服务器读取文件并计算出文件指纹，将文件指纹放在响应头的`Etag`字段中跟资源一起返回给客户端。
2. 第二次请求资源，客户端自动从缓存中读取上一次服务器返回的`Etag`，并赋给请求头的`If-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端。
3. 服务端拿到请求头中的`If-None-Match`字段，并再次读取目标资源生成文件指纹，两个指纹对比。如果吻合，说明文件没有被改变，则直接返回`304`状态码和返回一个空的响应体。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的`Etag`中并返回给客户端。
	
协商缓存字段：`Last-Modified/If-Modified-Since`、`Etag/If-None-Match`

- `Etag/If-None-Match`返回一个校验码。服务器根据浏览器发送的`If-None-Match`值来判断是否命中缓存。
- 当服务器返回`304 Not Modified`响应时，由于`Etag`重新生成过，响应`header`中还会把这个`Etag`返回，即使这个`Etag`跟之前的值没有变化。
- `Last-Modified/If-Modified-Since`：浏览器第一个请求资源时，服务器返回的`header`中会包含`If-Modified-Since`，该值为缓存之前返回的`Last-Modified`。服务器收到`If-Modified-Since`后，根据资源的最后修改时间判断是否命中缓存。
- 如果命中缓存，则返回`304`，并且不会返回资源内容，也不会返回`Last-Modified`。

`Last-Modified`与`ETag`一起使用时，服务器会优先验证`Etag`，一致的情况下，才会继续比对`Last-Modified`，最后才决定是否返回`304`。

`Cache-Control`使用相对时间，`Expires`(已废弃)使用基于服务器的绝对时间，一般采用`Cache-Control`，在请求设置了缓存的数据时，会先查看是否过期，如果没有过期直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次响应设置了`Etag`值会在这次请求的时候作为`If-None-Match`的值交给服务器校验，如果一致，继续校验`Last-Modified`，没有设置`Etag`则直接验证`Last-Modified`，再决定是否返回`304`。

浏览器缓存优点：

1. 减少冗余的数据传输
2. 减少服务器负担
3. 加快客户端加载网页的速度

第一次请求时，服务器会将页面最后修改时间通过`Last-Modified`标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个`Etag`，并发送给客户端。

浏览器请求资源时，会先获取该资源缓存的`header`信息，然后根据`header`中的`Cache-Control`和`Expires`(已废弃)来判断是否过期。如果没过期就直接从缓存中获取资源信息，包括缓存的`header`信息，所以此次请求不会与服务器进行通信。

如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的`header`字段信息，比如客户端会通过`If-None-Match`头将接收到的`Etag`发送给服务器，服务器与客户端会对比`Etag`是否相同。如果相同，就将`If-None-Match`置为`false`，返回状态`304`，客户端继续使用本地缓存，不解析接收的响应数据。否则，`If-None-Match`置为`true`，返回状态`200`，客户端解析接收的响应数据。客户端还会通过`If-Modified-Since`头将最后修改时间戳发送给服务器，服务器通过这个时间戳判断客户端的页面是否是最新。如果不是最新，则返回最新内容，否则，返回`304`，客户端继续使用本地缓存。

![](https://s1.ax1x.com/2022/10/12/xUlTsA.png)

