# `Vue`响应式系统

当数据模型`data`变化时，页面视图会得到响应更新，其原理对`data`的`getter/setter`方法进行拦截（`Object.defineProperty`或`Proxy`），利用发布订阅的设计模式，在`getter`方法中进行订阅，在`setter`方法中发布通知，让所有订阅者完成响应。

在响应式系统中，`Vue`会为数据模型`data`的每一个属性新建一个订阅中心作为发布者，而监听者`watch`、计算属性`computed`、视图渲染`template/render`三个角色同时作为订阅者。

- 对于监听器`watch`，会直接订阅观察者监听的属性
- 对于计算属性`computed`和视图渲染`template/render`，如果内部执行获取了`data`的某个属性，就会执行该属性的`getter`方法，然后自动完成对该属性的订阅，当属性被修改时，就会执行该属性的`setter`方法，从而完成该属性的发布通知，通知所有订阅者进行更新。

# `computed`与`watch`的区别

计算属性`computed`和监听器`watch`都可以观察属性的变化从而做出响应，不同的是：

- 计算属性`computed`更多是作为缓存功能的观察者，它可以将一个或多个`data`的属性进行复杂的计算生成一个新的值，提供给渲染函数使用，当依赖的属性变化时，`computed`不会立即重新计算生成新的值，而是先标记为脏数据，当下次`computed`被获取时，才会进行重新计算并返回。
- 监听器`watch`并不具备缓存性，监听器`watch`提供一个监听函数，当监听的属性发生变化时，会立即执行该函数。

# `Vue`的生命周期

- `beforeCreate`：`new Vue()`之后触发的第一个钩子，在当前阶段`data`、`method`、`computed`以及`watch`上的数据和方法都不能访问。
- `created`：在实例创建完成后发生，当前阶段已经完成了数据观测，可以使用数据、更改数据，在这里更改数据不会触发`updated`函数。可以做一些初始数据的获取，在当前阶段无法与`DOM`进行交互，如果有必要，则可以通过`vm.$nextTick`来访问`DOM`。
- `beforMount`：发生在挂载之前，在这之前`template`模板已导入渲染函数编译。当前阶段虚拟`DOM`已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发`updated`函数。
- `mounted`：在挂载完成后发生，当前阶段真实的`DOM`挂载完毕，数据完成双向绑定，可以访问到`DOM`节点，使用`$refs`属性对`DOM`进行操作。
- `beforeUpdated`：发生在更新之前，也就是响应式数据发生更新，虚拟`DOM`重新渲染之前被触发，可以在当前阶段进行更改数据，不会造成重渲染。
- `updated`：发生在更新完成之后，当前阶段组件`DOM`已完成更新。要注意避免在此期间更改数据，这可能会导致无限循环的更新。
- `beforeDestroy`：发生在实例销毁之前，当前阶段实例完成可以被使用，可以在这里进行善后收尾工作，比如清除定时器。
- `destroyed`：发生在实例销毁之后，这时只剩下了`DOM`空壳。组件已被拆解，数据绑定被卸除，监听被移除，子实例也都被销毁。

`<keep-alive>`包裹的路由组件，该组件有两个特有的生命周期函数：`activated`和`deactivated`。其中`activated`在路由组件被激活时触发，`deactivated`在路由组件失活时触发。

# 组件的`data`必须是一个函数

一个组件可能在很多地方使用，也就是会创建很多个实例，如果`data`是一个对象，对象是引用类型，一个实例修改了`data`会影响到其他实例，所以`data`必须使用函数为每一个实例创建一个属于自己的`data`，使其同一个组件的不同实例互不影响。

# 组件通信

- 父子组件通信
父组件->子组件：`prop`
子组件->父组件：`$on/$emit`
获取组件实例：使用`$parent/$children`、`$refs`，获取到实例后直接获取属性数据或调用组件方法

- 兄弟组件通信
`Event Bus`：每一个`Vue`实例都是一个`Event Bus`，都支持`$on/$emit`，可以为兄弟组件的实例之间`new`一个`Vue`实例，作为`Event Bus`进行通信。
`Vuex`：将状态和方法提取到`Vuex`，完成共享。

- 跨级组件通信
使用`provide/inject`、`Event Bus`、`Vuex`

# `Vue`事件绑定原理

每一个`Vue`实例都是一个`Event Bus`，当子组件被创建时，父组件将事件传递给子组件，子组件初始化时是有`$on`方法将事件注册到内部，在需要时使用`$emit`触发函数，而对于原生`native`事件，使用`addEventListener`绑定到真实的`DOM`元素上。

# `slot`原理

`slot`插槽，是`Vue`的内容分发机制，组件内部的模板引擎使用`slot`元素作为承载分发内容的出口。插槽`slot`是子组件的一个模板标签元素，而这个标签元素是否显示，以及如何显示是由父组件决定的。

`slot`分三类，默认插槽、具名插槽和作用域插槽。

- 默认插槽：又名匿名插槽，当`slot`没有指定`name`属性值的时候一个默认显示插槽，一个组件内只有一个匿名插槽。
- 具名插槽：带有具体名字的插槽，也就是带有`name`属性的`slot`，一个组件可以出现多个具名插槽。
- 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件传递过来的数据决定如何渲染该插槽。

# `Vue`模板渲染原理

`Vue`中的模板`template`无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的`HTML`语法，所以需要将`template`转化为一个`JavaScript`函数，这样浏览器就可以执行这个函数并渲染出对应的`HTML`元素，完成视图渲染，这个转化的国产，就称为模板编译。

模板编译分三个阶段，解析`parse`、优化`optimize`，生成`generate`，最终生成可执行函数`render`。

- `parse`阶段：使用大量的正则表达式对`template`字符串进行解析，将标签、指令、属性等转化为抽象语法树`AST`。
- `optimize`阶段：遍历`AST`，找到其中的一些静态节点并进行标记，方便在页面重渲染时进行`diff`比较，直接跳过这一些静态节点，优化`runtime`运行时的性能。
- `generate`阶段：将最终的`AST`转化为`render`函数字符串。

# `template`预编译

对于`Vue`组件来说，模板编译只会在组件实例化时编译一次，生成渲染函数之后再也不会进行编译。因此，编译对组件的`runtime`是一种性能损耗。而模板编译的目的仅仅是将`template`转化为`render`函数，这个过程正好可以在项目构建的过程中完成，这样可以让实际组件在`runtime`时直接跳过模板渲染，进而提升性能，这个在项目构建的编译`template`的过程，就是预编译。

# `Virtual DOM`

`virtual dom`是`DOM`节点在`JavaScript`中的一种抽象数据结构，之所以需要虚拟`DOM`，是因为在浏览器中操作`DOM`的代价比较昂贵，频繁操作`DOM`会产生性能问题。虚拟`DOM`的作用是在每一次响应式数据发生变化引起页面重新渲染时，`Vue`对比更新前后的虚拟`DOM`，匹配找出尽可能少的需要更新的真实`DOM`，从而达到提升性能的目的。

# `diff`算法

在新旧虚拟`DOM`对比时

- 首先，对比节点本身，判断是否为同一节点，如果不是相同节点，则删除该节点重新创建节点进行替换。
- 如果是相同节点，进行`patchVnode`，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况（如果新的`children`没有子节点，将旧的子节点移除）。
- 比较如果都有子节点，则进行`updateChildren`，判断如何对这些新旧节点的子节点进行操作（`diff`核心）。
- 匹配时，找到相同的子节点，递归比较子节点。

在`diff`中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂度从`O(n^3)`降低到`O(n)`，也就是说，只有当新旧`children`都为多个子节点时才需要用核心的`diff`算法进行同层级比较。

# `key`属性的作用

在对节点进行`diff`的过程中，判断是否为相同节点的一个很重要的条件是`key`是否相等，如果是相同节点，则会尽可能复用原有的`DOM`节点。所以`key`属性是提供给框架在`diff`的时候使用的，而非开发者。

# `Vue2`和`Vue3`的区别

1、 重构响应式系统，使用`Proxy`替换`Object.defineProperty`，使用`Proxy`优势：

- 可直接监听数组类型的数据变化
- 监听的目标为对象本身，不需要像`Object.defineProperty`一样遍历每个属性，有一定的性能提升
- 可拦截`apply`、`ownKeys`、`has`等`13`中方法，而`Object.defineProperty`不行
- 直接实现对象属性的新增/删除

2、新增`Composition API`，更好的逻辑复用和代码组织。

3、重构`Virtual DOM`

- 模板编译时的优化，将一些静态节点编译成常量
- `slot`优化，将`slot`编译为`lazy`函数，将`slot`渲染的决定权交给子组件
- 模板中内联事件的提取并重用（原本每次渲染都重新生成内联函数）

4、代码结构调整，更便于`Tree Shaking`，使得体积更小

5、使用`TypeScript`替换`Flow`


