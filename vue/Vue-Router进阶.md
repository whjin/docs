**导航守卫**

导航守卫主要用来通过跳转或取消的方法守卫导航。

**全局前置守卫**

可以使用`router.beforeEach`注册一个全局前置守卫。

当一个导航触发时，全局前置守卫安装创建顺序调用。守卫是异步解析执行，此时导航在所有守卫`resolve`完之前一致处于等待中。

每个守卫方法接收两个参数：

- `to`：即将要进入的目标
- `from`：当前导航正要离开的路由
- `next`

**全局解析守卫**

可以用`router.beforResolve`注册一个全局守卫。它在每次导航时都会触发。确保在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被正确调用。

`router.beforeResolve`是获取数据或执行任何其他操作的理想位置。

**全局后置钩子**

可以注册全局后置钩子，和守卫不同，这些钩子不会接受`next`函数也不会改变导航本身。

**路由独享的守卫**

可以直接在路由配置上定义`beforeEnter`守卫。

`beforeEnter`守卫只在进入路由时触发，不会在`params`、`query`或`hash`改变时触发。只有在从一个不同的路由导航时，才会被触发。

**完整的导航解析流程**

1. 导航被触发
2. 在失活的组件里调用`beforeRouteLeave`守卫
3. 调用全局的`beforeEach`守卫
4. 在重用的组件里调用`beforeRouteUpdate`守卫
5. 在路由配置里调用
6. 解析异步路由组件
7. 在被激活的组件里调用`beforeRouteEnter`
8. 调用全局的`beforeResolve`守卫
9. 导航被确认
10. 调用全局的`afterEach`钩子
11. 触发`DOM`更新
12. 调用`beforeRouteEnter`守卫中传给`next`的回调函数，创建好的组件实例会作为回调函数的参数传入

**路由元信息**

将任意信息附加到路由上，可以通过接收`meta`属性实现，并且它可以在路由地址盒导航守卫上都被访问到。

`routes`配置中的每个路由对象为路由记录。

一个路由匹配到的所有路由记录会暴露为`$route`对象（还有在导航守卫中的路由对象）的`$route.matched`数组。

**数据获取**

- 导航完成之后获取：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的提示
	使用这种方式，会马上导航和渲染组件，然后在组件的`created`钩子中获取数据。
- 导航完成之前获取：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航
	使用这种方式，在导航转入新的路由前获取数据。可以在接下来的组件的`beforeRouteEnter`守卫中获取数据，当数据获取成功后只调用`next`方法。

**在setup中访问路由和当前路由**

在`setup`里面没有访问`this`，不能直接访问`this.$router`或`this.$route`。作为替代，使用`useRouter`函数。

`const route = userRoute()`，`route`对象是一个响应式对象，它的任何属性都可以被监听，应该避免监听整个`route`对象。在大多数情况下，应该直接监听期望改变的参数。

**导航守卫**

仍然可以通过`setup`函数来使用组件内的导航守卫，但`Vue Router`将更新和离开守卫作为组合式`API`函数公开。

组合式`API`守卫可以用在任何由`<router-view>`渲染的组件中，它们不必像组件内守卫那样直接用在路由组件上。

**useLink**

`Vue Router`将`RouterLink`的内部行为作为一个组合式`API`函数公开。它提供了与`v-slot API`相同的访问属性。

**单个路由的过渡**

让每个路由的组件有不同的过渡，可以将元信息和动态的`name`结合在一起，放在`<transition>`上。

**基于路由的动态过渡**

根据目标路由和当前路由之间的关系，动态地确定使用的过渡。

可以添加一个`after.navigation.hook`，根据路径的深度动态添加信息到`meta`字段。

**滚动行为**

这个功能只在支持`history.pushState`的浏览器中可用。

`scrollBehavior`函数接收`to`和`from`路由对象。第三个参数`savePosition`，只有当这是一个`popState`导航时才可用（由浏览器的后退/前进按钮触发）。

**路由懒加载**

当打包构建应用时，`JS`包会变得非常大，影响页面加载。把不同路由对应的组件分割成不同的代码块，然后由路由被访问的时候才加载对应组件，这样就会更高效。

`Vue Router`支持开箱即用的动态导入，可以用动态导入代替静态导入。

`component/components`配置接收一个返回`Promise`组件的函数，`Vue Router`只会在第一次进入页面时才会获取这个函数，然后使用缓存数据。

**把组件按组分块**

使用`webpack`：把某个路由下的所有组件都打包在同个异步块`chunk`中。只需要使用命名`chunk`，一个特殊的注释语法来提供`chunk name`。

`webpack`会将任何一个异步模块与相同的块名称组合到相同的异步块中。

**等待导航结果**

当使用`router-link`组件时，`Vue Router`会在自动调用`router.push`来触发一次导航。

- 用户已经位于他们正在尝试导航到的页面
- 一个导航守卫通过调用`return false`中断了这次导航
- 当前的导航守卫还没有完成时，一个新的导航守卫会出现
- 一个导航守卫通过返回一个新的位置，重定向到其他地方
- 一行导航守卫抛出一个`Error`

**检测导航故障**

如果导航被阻止，导致用户停留在同一个页面上，由`router.push`返回的`Promise`的解析值将是`Navigation Failure`。否则，它将是一个`falsy`值（通常是`undefined`）。这样就可以区分导航是否离开了当前位置。

**鉴别导航故障**

可以用`isNavigationFailure`和`NavigationFailureType`来区分。总共有三种不同的类型：

- `aborted`：在导航守卫中返回`false`中断了本次导航
- `cancelled`：在当前导航还没有完成之前又有了一个新的导航。
- `duplicated`：导航被阻止，已经在目标位置

**导航故障的属性**

所有的导航失败都会暴露`to`和`from`属性，以反映失败导航的当前位置和目标位置。

在所有情况下，`to`和`from`都是规范化的路由地址。

**检测重定向**

当在导航守卫中返回一个新的位置时，会触发一个新的导航，覆盖正在进行的导航。与其他返回值不同的是，重定向不会阻止导航，而是创建一个新的导航。因此，通过读取路由地址中的`redirectedFrom`属性，对其进行不同的检查。

